
# tree_genotype.py

import random
from copy import deepcopy
#from fitness import manhattan, I ADDED manhattan at the end of the code.
import numbers
from math import inf

class TreeGenotype():
    def __init__(self):
        self.genes = None
        self.fitness = 0
        self.base_fitness = 0
        self.log = None
        self.fights = 0
        self.sum_fitness = 0
        self.sum_base_fitness = 0
        self.size = 0

    @classmethod
    def initialization(cls, mu, **kwargs):
        population = [cls() for _ in range(mu)]


        # 2a TODO: Initialize genes member variables of individuals
        #          in population using ramped half-and-half.
        #          Pass **kwargs to your functions to give them
        #          the sets of terminal and nonterminal primitives.

        depth_limit = kwargs['depth_limit']
        for i in range(mu):
            kwargs['depth_limit'] = random.randint(1, depth_limit)
            if (i % 2 == 0):
                population[i].genes = ParseTree().full(**kwargs)
            else:
                population[i].genes = ParseTree().grow(**kwargs)

        return population
        
    def serialize(self):
        # 2a TODO: Return a string representing self.genes in the required format
        def traverse(node, depth):
            if node is None:
                return []
        
            # Create a string for the current node with pipes 
            if isinstance(node.data, (int, float)):
                node_str = f"{'|' * depth}{str(float(node.data))}"
            else:
                node_str = f"{'|' * depth}{node.data}"

            result = [node_str]
        
            # Add the left and right children
            if node.left:
                result.extend(traverse(node.left, depth + 1))
            if node.right:
                result.extend(traverse(node.right, depth + 1))
        
            return result

        if self.genes and hasattr(self.genes, 'root'):
            # Return a string representing self.genes in the required format.
            serialized_tree = traverse(self.genes.root, 0)
            return '\n'.join(serialized_tree)
        else:
            return ""

    def deserialize(self, serialization):
        # 2a TODO: Complete the below code to recreate self.genes from serialization,
        #          which is a string generated by your serialize method.
        #          We have provided logic for tree traversal to help you get started,
        #          but you need to flesh out this function and make the genes yourself.

        lines = serialization.split('\n')
    
        # TODO: Create the root node yourself here based on lines[0]
        root_value = lines[0].lstrip('|')
        root = Node(data=float(root_value) if '.' in root_value or root_value.isdigit() else root_value)
        self.genes = ParseTree()
        self.genes.root = root
        parent_stack = [(root, 0)]

        # Process each line
        for line in lines[1:]:
            my_depth = line.count('|')
            my_primitive = line.strip('|')
            node = Node(data=float(my_primitive) if '.' in my_primitive or my_primitive.isdigit() else my_primitive)

            # Check the stack for the parent 
            while parent_stack and parent_stack[-1][1] >= my_depth:
                parent_stack.pop()

            if parent_stack:  
                parent, _ = parent_stack[-1]
                if not parent.left:
                    parent.left = node
                else:
                    parent.right = node

            parent_stack.append((node, my_depth))

    def evaluate(self, state, player):
        if self.genes:
            return self.genes.evaluate(state, player)
        else:
            return 0

    def recombine(self, mate, depth_limit, **kwargs):
        child = self.__class__()
        child.genes = ParseTree()  # Initialize child.genes as a ParseTree instance
        child.genes.root = deepcopy(self.genes.root) 


        # 2b TODO: Recombine genes of mate and genes of self to
        #          populate child's genes member variable.
        #          We recommend using deepcopy, but also recommend
        #          that you deepcopy the minimal amount possible.

        self_subtree = self.genes.select_random_node(self.genes.root)
        mate_subtree = mate.genes.select_random_node(mate.genes.root)

        # Calculate depth of subtrees
        def subtree_depth(node):
            if node is None:
                return 0
            return 1 + max(subtree_depth(node.left), subtree_depth(node.right))
    
        # Perform the crossover only if the resulting tree respects depth_limit
        if subtree_depth(self_subtree) + self_subtree.depth <= depth_limit:
            if self_subtree.parent:
                if self_subtree.parent.left is self_subtree:
                    self_subtree.parent.left = deepcopy(mate_subtree)
                elif self_subtree.parent.right is self_subtree:
                    self_subtree.parent.right = deepcopy(mate_subtree)
            else:
                # If the selected node is the root, replace the entire tree
                child.genes.root = deepcopy(mate_subtree)
        return child


    def mutate(self, depth_limit, **kwargs):
        mutant = self.__class__()
        mutant.genes = deepcopy(self.genes)

        # 2b TODO: Mutate mutant.genes to produce a modified tree.
        target_node = mutant.genes.select_random_node(mutant.genes.root)
    
        # Generate a new subtree with the same depth constraints as the current tree
        new_subtree = ParseTree()
        current_depth = target_node.depth
        new_subtree.grow(current_depth=current_depth, depth_limit=depth_limit, **kwargs)

        # Check if target node has a parent to attach the mutated subtree
        if target_node.parent:
            # Attach the new subtree to the parent of the target node
            if target_node.parent.left is target_node:
                target_node.parent.left = new_subtree.root
            elif target_node.parent.right is target_node:
                target_node.parent.right = new_subtree.root
        else:
        # If the target node is the root, replace the root
            mutant.genes.root = new_subtree.root
        return mutant
        
class Node:
    def __init__(self, data, depth=0, left=None, right=None, parent=None):
        self.data = data
        self.left = left
        self.right = right
        self.depth = depth
        self.parent = parent
        
        if self.data == 'C':
            self.data = round(random.uniform(-5, 5) * 100) / 100

    def is_leaf(self):
        return not self.left and not self.right

class ParseTree:
    def __init__(self):
        self.root = None

    def grow(self, current_depth=0, current_node=None, **kwargs):
        max_depth = kwargs['depth_limit']
        terminals = kwargs['terminals']
        nonterminals = kwargs['nonterminals']
        #select a random node to grow]
        if self.root is not None:
            selected_node = self.select_random_node(self.root)
            self.grow_from_node(selected_node, current_depth, kwargs['depth_limit'], kwargs['terminals'], kwargs['nonterminals'])
        else:
            #start growing if tree is empty 
            self.root = self.create_node(current_depth, kwargs['depth_limit'], kwargs['terminals'], kwargs['nonterminals'])
            self.grow_from_node(self.root, current_depth, kwargs['depth_limit'], kwargs['terminals'], kwargs['nonterminals'])
        return self

    def grow_from_node(self, node, current_depth, max_depth, terminals, nonterminals):
        if node.is_leaf() and current_depth < max_depth:
            if node.data in terminals or isinstance(node.data, numbers.Number):
                return
            # Create left and right children with parent references
            node.left = self.create_node(current_depth + 1, max_depth, terminals, nonterminals, parent=node)
            self.grow_from_node(node.left, current_depth + 1, max_depth, terminals, nonterminals)
            node.right = self.create_node(current_depth + 1, max_depth, terminals, nonterminals, parent=node)
            self.grow_from_node(node.right, current_depth + 1, max_depth, terminals, nonterminals)
        elif current_depth >= max_depth:
            # Create a terminal node at the depth limit
            node = self.create_node(current_depth, max_depth, terminals, (), parent=node)
    
    def create_node(self, current_depth, max_depth, terminals, nonterminals, parent=None):
        if current_depth < max_depth:
            node_data = random.choice(nonterminals + terminals)
        else:
            node_data = random.choice(terminals)
        
        # Create the node with a parent reference
        node = Node(data=node_data, depth=current_depth, parent=parent)
        if node.data == 'C' and current_depth < max_depth:
            node.left = self.create_node(current_depth + 1, max_depth, terminals, nonterminals, parent=node)
            node.right = self.create_node(current_depth + 1, max_depth, terminals, nonterminals, parent=node)
    
        return node

    def full(self, current_depth=0, current_node=None, **kwargs):
        max_depth = kwargs['depth_limit']       
        if current_node is None:
            self.root = self.create_node(current_depth, max_depth, (), kwargs['nonterminals'])
            current_node = self.root
        
        if current_depth + 1 == max_depth:
            current_node.left = self.create_node(current_depth + 1, max_depth, kwargs['terminals'], ())
            current_node.right = self.create_node(current_depth + 1, max_depth, kwargs['terminals'], ())
        else:
            current_node.left = self.create_node(current_depth + 1, max_depth, (), kwargs['nonterminals'])
            current_node.right = self.create_node(current_depth + 1, max_depth, (), kwargs['nonterminals'])
            self.full(current_depth + 1, current_node.left, **kwargs)
            self.full( current_depth + 1, current_node.right, **kwargs)
        return self
    #Evalutin left and right childs 
    def evaluate(self, state, player, current_node=None):
        if current_node is None:
            current_node = self.root

        if current_node.is_leaf():
            return self.evaluate_terminal(state, current_node, player)
        left_value = self.evaluate(state, player, current_node.left)
        right_value = self.evaluate(state, player, current_node.right)

        return self.apply_operation(current_node.data, left_value, right_value)

    def evaluate_terminal(self, state, terminal, player):
        if player != 'm':
            player = int(player) + 1

        if terminal.data == 'G':
            if (player == 'm'):
                players = list(state['players'].values())
                player_pos = players[0]
                ghost_pos_array = [ghost for ghost in players[1:]]
                manhattan_distances = [manhattan(player_pos, ghost_pos) for ghost_pos in ghost_pos_array]
                return min(manhattan_distances)
            else:
                players = list(state['players'].values())
                ghost_pos = players[int(player)]
                other_ghost_pos_array = [ghost for ghost in players if ghost != ghost_pos]
                manhattan_distances = [manhattan(ghost_pos, other_ghost_pos) for other_ghost_pos in other_ghost_pos_array]
                return min(manhattan_distances)
        
        elif terminal.data == 'M':
            players = list(state['players'].values())

            if player == 'm':  
                pacman_pos = players[0] 
                return 0 
            else:
                try:
                    ghost_pos = players[int(player)]  
                    pacman_pos = players[0]  
                    manhattan_distance_to_pacman = manhattan(ghost_pos, pacman_pos)
                    return manhattan_distance_to_pacman
                except IndexError:
                    raise ValueError(f"Invalid player index: {player}. Check the state data structure.")


        
        elif terminal.data == 'P':
            # manahattan distance to nearest pill
            players = list(state['players'].values())
            if player == 'm':
                player_pos = players[0]
            else:
                player_pos = players[int(player)]
            pills = list(state['pills'])
            manhattan_distances = [manhattan(player_pos, pill) for pill in pills]
            return min(manhattan_distances)
        
        elif terminal.data == 'F':
            if state['fruit'] == None:
                return 0

            players = list(state['players'].values())
            if player == 'm':
                player_pos = players[0]
            else:
                player_pos = players[int(player)]
            fruit = state['fruit']
            return manhattan(player_pos, fruit)

        elif terminal.data == 'W':
            players = list(state['players'].values())
            if player == 'm':
                player_pos = players[0]
            else:
                player_pos = players[int(player)]
            walls = state['walls']
            
            wall_count = 0
            for coordinate in player_pos:
                if coordinate == 0:
                    wall_count += 1
            if (player_pos[0] > 0 and walls[player_pos[0] - 1][player_pos[1]]):
                wall_count += 1
            if (player_pos[0] < len(walls) - 1 and walls[player_pos[0] + 1][player_pos[1]]):
                wall_count += 1
            if (player_pos[1] > 0 and walls[player_pos[0]][player_pos[1] - 1]):
                wall_count += 1
            if (player_pos[1] < len(walls[0]) - 1 and walls[player_pos[0]][player_pos[1] + 1]):
                wall_count += 1
                
            return wall_count

        elif isinstance(terminal.data, numbers.Number):
            return terminal.data

    #apply the operation to the left and the right sides 
    def apply_operation(self, operation, left_value, right_value):
  
        if operation == '+':
            return left_value + right_value
        elif operation == '-':
            return left_value - right_value
        elif operation == '*':
            return left_value * right_value
        elif operation == '/':
            return left_value / right_value if right_value != 0 else self.handle_division_by_zero(left_value)
        elif operation == 'RAND':
            return random.uniform(min(left_value, right_value), max(left_value, right_value))

    # handling division by zero
    def handle_division_by_zero(self, numerator):

        return numerator  

    def __str__(self, current_node=None, depth=0):
        if current_node is None:
            current_node = self.root

        result_str = '|' * depth + str(current_node.data) + '\n'

        if current_node.left:
            result_str += self.__str__(current_node.left, depth + 1)
        
        
        if current_node.right:
            result_str += self.__str__(current_node.right, depth + 1)

        return result_str

    def count_nodes(self, root):
        if root is None:
            return 0
        if root == 'root':
            root = self.root

        return 1 + self.count_nodes(root.left) + self.count_nodes(root.right)
    
    def select_random_node(self, root):
        count = self.count_nodes(root)
        rand_count = random.randint(1, count)
        stack = []
        current = root
        while stack or current:
            if current:
                stack.append(current)
                current = current.left  
            else:
                current = stack.pop()
                rand_count -= 1
                if rand_count == 0:
                    return current  
                current = current.right  

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])